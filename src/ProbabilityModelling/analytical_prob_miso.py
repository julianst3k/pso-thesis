from aux import cotan, UniformRectangle, EightRectangle, ProbabilityCalculator, IntegrationLimit, Orientation, Interval, Bound, OffsetInterval
import numpy as np
from analytical_prob_siso import AnalyticalProbability
import equation_solvers as eq

class AnalyticalMISO(AnalyticalProbability):
    def __init__(self, X, Y, x_center, y_center, fov, beta, h, r, threshs, d):
        super().__init__(X, Y, x_center, y_center, fov, beta, h, r, threshs)
        self.lims_base = self.lims
        self.d = d
        self.rect = UniformRectangle(X, Y, x_center, y_center, 360)
        self._solve_lims_offset()
    
    def _solve_lims_offset(self, theta=None):
        thresh_solver = eq.ThresholdSolver(self.threshs)
        self.offset_lims = thresh_solver.solve_lims_offset(self, theta)
        print(self.offset_lims)
        
    def _solve_base_wrapper(self):
        lims = self.lims
        base_solver = eq.ArccosEquationSolver(self.threshs)
        self.sol_base_equations = base_solver.solve_base_equations(self.rect, self)
        for triangle in self.rect:
            self._sort_intervals_by_lb(self.sol_base_equations[triangle])
            self.sol_base_equations[triangle] = self.divide_by_lims(self.sol_base_equations[triangle], self.lims)
    
    def _solve_offset_wrapper(self):
        base_solver = eq.ArccosEquationSolver(self.threshs)
        self.sol_offset_equations = base_solver.solve_offset_equations(self.rect, self)
        for triangle in self.rect:
            self._sort_intervals_by_lb(self.sol_offset_equations[triangle])
            self.sol_offset_equations[triangle] = self.divide_by_lims(self.sol_base_equations[triangle], self.offset_lims[triangle])
        
    def eq_offset(self, L, theta, neg=1, pivot = False):
        off = np.arctan(L*np.sin(theta)/(L*np.cos(theta)+d))+pivot*np.pi

        return neg*np.arccos((self.cosfov*np.sqrt(L**2+2*d*L*np.cos(theta)+d**2+self.b**2)-self.a)/(np.sqrt(L**2+d**2+2*d*L*np.cos(theta))*self.sinbeta))-off
    
    def eq_base(self, L, theta, neg=1):
        return neg*np.arccos((self.cosfov*np.sqrt(L**2+self.b**2)-self.a)/(L*self.sinbeta))-theta
    
    def _sort_intervals_by_lb(self, list_of_intervals):
        list_of_intervals.sort(key = lambda interval: interval.lb)

    
    def divide_by_lims(self, list_of_intervals, list_of_thresholds):
        """
        Input:
        list_of_intervals: The list of intervals generated by Arccos_Equation_Solver
        list_of_thresholds: The list of thresholds generated by Treshold_Equation_Solver
        Result: A new list of intervals
        """
        current_interval = 0
        return_interval = []
        for i, lim in self.lims:
            not_completed = current_interval < len(list_of_intervals)
            while not_completed:
                curr = list_of_intervals[current_interval]
                if self.from_one and i==0:
                    if lim.low <= curr.ub:
                        _ = curr.inverse_divide_interval(lim.low)
                        curr.set_consts(lim.const)
                if lim.low <= curr.ub:
                    curr.set_consts(lim.const)
                    if lim.high > curr.ub:
                        added_interval = curr.inverse_divide_interval(lim.high)
                        new_intervals.append(added_interval)
                        break                                
                    else:
                        new_intervals.append(curr)
                        current_interval += 1
                        if lim.high == curr.ub:
                            break
                else:
                    current_interval += 1
                    continue
        self._sort_intervals_by_lb(return_interval)
        return return_interval

        
    
if __name__ == "__main__":
    beta = np.pi/180*45
    fov = np.pi/180*30
    r = 0.05
    h = 1.2
    x_c = 1
    y_c = 1
    X = 5
    Y = 3
    d = 1
    threshs = [{"thr": -1, "consts": 1},
               {"thr": -0.9, "consts": {"a":-3.2, "b": -0.2}},
               {"thr": -0.6, "consts": {"a":-1.51, "b": 1.3}},
               {"thr": 0.6, "consts": {"a":-1, "b":np.pi/2}},
               {"thr": 0.9, "consts": {"a":-1.51, "b": 1.85}},
               {"thr": 1, "consts": {"a":-3.2, "b": -3.3}}]
    an_prob = AnalyticalMISO(X, Y, x_c, y_c, fov, beta, h, r, threshs, d)
    
    an_prob._solve_lims_offset(theta=3.5)
    an_prob.print_lims()
