from aux import cotan, UniformRectangle, EightRectangle, ProbabilityCalculator, IntegrationLimit, Orientation
from integral_funcs import RectangleIntegrator
import numpy as np
import equation_solvers as eq
from interval import OutOfUnitaryBound
from montecarlo_prob import MonteCarloIntegrator


class AnalyticalProbability(ProbabilityCalculator):
    def __init__(self, X, Y, x_center, y_center, fov, beta, h, r, threshs):
        super().__init__(fov, beta, h, r)
        self.rect = EightRectangle(X, Y, x_center, y_center)
        self.X = X
        self.Y = Y
        self.threshs = threshs
        self.from_one = False
        self.alpha = 0
        self.solve_thresholds()

    def arg_acos(self, u):
        return (self.cosfov*np.sqrt(u**2+self.b**2)-self.a)/(u*self.sinbeta)
    def eq_base(self, L, theta, neg=1, pivot = False, is_offset = False):
        ct = (self.cosfov*np.sqrt(L**2+self.b**2)-self.a)/(L*self.sinbeta)
        if np.abs(ct)-1 > 1e-4:
            raise OutOfUnitaryBound
        elif np.abs(ct) > 1:
            ct = np.abs(ct)/ct 
        
        return  2*np.pi*is_offset + neg*np.arccos(ct)-theta
    def eq_base_int(self, L, interval, theta, offset):
        sign = (-1)**(interval.is_neg)
        return self.eq_base(L, theta, sign, interval.pivoted, offset)
    def _sort_intervals_by_lb(self, list_of_intervals):
        list_of_intervals.sort(key = lambda interval: interval.lb)

    def solve_thresholds(self):
        thresh_solver = eq.ThresholdSolver(self.threshs)
        self.lims = thresh_solver.solve_equations(self)
    def print_lims(self, lims = None):
        if lims is None:
            lims = self.lims

    
    def calculate_probability(self):
        integrator = RectangleIntegrator(self.rect)
        summ = 0
        for lim in self.lims:
            if lim.const != 1:
                summ += integrator.non_origin_integrator(lim.low, lim.high, lim.const, self)
            else:
                summ += integrator.origin_integrator(lim.high)
        return summ

    def divide_by_lims(self, list_of_intervals, list_of_thresholds):
        """
        Input:
        list_of_intervals: The list of intervals generated by Arccos_Equation_Solver
        list_of_thresholds: The list of thresholds generated by Treshold_Equation_Solver
        Result: A new list of intervals
        """
        current_interval = 0
        return_interval = []
        for i, lim in enumerate(list_of_thresholds):
            if lim.high == lim.low:
                continue
            while current_interval < len(list_of_intervals):
                curr = list_of_intervals[current_interval]
                if curr.lb < lim.low:
                    _ = curr.inverse_divided_interval(lim.low)
                if lim.low <= curr.ub:
                    if lim.high < curr.lb:
                        break
                    curr.set_consts(lim.const)
                    if lim.high < curr.ub and lim.high > curr.lb:
                        added_interval = curr.inverse_divided_interval(lim.high)
                        return_interval.append(added_interval)
                        break                                
                    else:
                        return_interval.append(curr)
                        current_interval += 1
                        if lim.high == curr.ub:
                            break
                else:
                    current_interval += 1
                    continue
        self._sort_intervals_by_lb(return_interval)
        return return_interval
    def interval_pairing(self, first_set, second_set, debug = False):
        """
        It is assumed that both first and second sets are ordered
        """
        current_interval = 0
        return_interval = []
        for i, inter in enumerate(first_set):
            not_completed = current_interval < len(second_set)
            while not_completed:
                curr = second_set[current_interval]
                if debug:
                    print(curr, "Pairing")
                if inter.ub < curr.ub:
                    if inter.ub < curr.lb:
                        """
                        In this case, the interval is dismissed because no interval is intersecting
                        """
                        break
                    else:
                        if inter.lb <= curr.lb:
                            _ = inter.inverse_divided_interval(curr.lb) # We discard the lower half
                        new_curr = curr.inverse_divided_interval(inter.ub)
                        return_interval.append([inter, new_curr])

                        break
                else:
                    if inter.lb > curr.ub:
                        current_interval += 1 
                        not_completed = current_interval < len(second_set)
                    else:
                        new_inter = inter.inverse_divided_interval(curr.ub)
                        if new_inter.lb >= curr.lb:
                            _ = curr.inverse_divided_interval(new_inter.lb)
                        else:
                            _ = new_inter.inverse_divided_interval(curr.lb)
                        return_interval.append([new_inter, curr])
                        current_interval += 1
                        not_completed = current_interval < len(second_set)
        return return_interval

if __name__ == "__main__":
    beta = np.pi/180*45
    fov = np.pi/180*45
    r = 0.05
    h = 1.2
    x_c = 1
    y_c = 1
    X = 5
    Y = 3
    d = 1
    threshs = [{"thr": -1, "consts": 1},
               {"thr": -0.9, "consts": {"a":-3.2, "b": -0.2}},
               {"thr": -0.6, "consts": {"a":-1.51, "b": 1.3}},
               {"thr": 0.6, "consts": {"a":-1, "b":np.pi/2}},
               {"thr": 0.9, "consts": {"a":-1.51, "b": 1.85}},
               {"thr": 1, "consts": {"a":-3.2, "b": 3.3}}]
    an_prob = AnalyticalProbability(X, Y, x_c, y_c, fov, beta, h, r, threshs)
    beta_arr = np.linspace(20,80,60)
    fov_arr = np.linspace(20,80,60)    
    miso_arr = np.zeros((60,60,2))
    for u, beta in enumerate(beta_arr):
        for v, fov in enumerate(fov_arr):
            an_prob = AnalyticalProbability(X, Y, x_c, y_c, fov*np.pi/180, beta*np.pi/180, h, r, threshs)
            integrator = MonteCarloIntegrator()
            mont = integrator.siso_integrator(10000, beta = beta, fov = fov)
            miso_arr[u, v, :] = np.array([an_prob.calculate_probability(), mont])
            an_prob = AnalyticalProbability(X, Y, x_c, y_c, fov*np.pi/180, beta*np.pi/180, h, r, threshs)
            print(an_prob.calculate_probability(), mont)
    miso_arr.tofile("siso_arr.csv", sep=",")